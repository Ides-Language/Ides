tokens : {" ", "\n", "\r", "\t"} {"+", "-", "*", "/", "%", "^", "&", "|", "~", "!", "=", "<", ">", 
"+=", "-=", "*=", "/=", "%=", "^=", "&=", "|=", "<<", ">>", "<<=", ">>=", "==", "!=", "<=", ">=", "&&", "||", "++", "--", ",", "->*", "->",
"\"", ",", ";", "(", ")", "==", "<=", "[", "]", "[[", "]]", ":", "//", ".", 
"{", "}", "=>" };

semantic_atom cpp_comment_begin = (static) [[length(2)]] string requires(matches_string("//"));

semantic_atom cpp_comment_character = (static) [[length(1)]] string requires(matches_regex("[^\\n]"));

semantic_token cpp_comment_body
<
	{ cpp_comment_character }
>;

semantic_token cpp_comment
<
	cpp_comment_begin,
	cpp_comment_body,
	newline
>;

semantic_atom c_comment_begin = (static) [[length(2)]] string requires(matches_string("/*"));
semantic_atom c_comment_end = (static) [[length(2)]] string requires(matches_string("*/"));

semantic_atom c_comment_character = (static) [[length(1)]] string requires(matches_regex("[^\\*]"));
semantic_atom c_comment_non_terminator = (static) [[length(2)]] string requires(matches_regex("\\*[^/]"));

using c_comment_body_element = { c_comment_character, c_comment_non_terminator };

semantic_token c_comment_body
<
	{ c_comment_body_element }
>;

semantic_token c_comment
<
	c_comment_begin,
	c_comment_body,
	c_comment_end
>;

semantic_atom space = (static) [[length(1)]] string requires(matches_string(" "));
semantic_atom newline = (static) [[length(1)]] string requires(matches_string("\n"));
semantic_atom return = (static) [[length(1)]] string requires(matches_string("\r"));
semantic_atom tab = (static) [[length(1)]] string requires(matches_string("\t"));

semantic_atom whitespace_x = (static) [[longest()]] string requires(matches_regex("[ \\n\\r\\t]*"));

whitespace = { whitespace_x, cpp_comment, c_comment  };

semantic_atom operator_plus = string requires(matches_string("+"));
semantic_atom operator_minus = string requires(matches_string("-"));
semantic_atom operator_multiply = string requires(matches_string("*"));
semantic_atom operator_divide = string requires(matches_string("/"));
semantic_atom operator_modulo = string requires(matches_string("%"));
semantic_atom operator_xor = string requires(matches_string("^"));
semantic_atom operator_and = string requires(matches_string("&"));
semantic_atom operator_or = string requires(matches_string("|"));
semantic_atom operator_complement = string requires(matches_string("~"));
semantic_atom operator_not = string requires(matches_string("!"));
semantic_atom operator_equal = string requires(matches_string("="));
semantic_atom operator_less_than = string requires(matches_string("<"));
semantic_atom operator_greater_than = string requires(matches_string(">"));

semantic_atom operator_plus_plus = string requires(matches_string("++"));
semantic_atom operator_minus_minus = string requires(matches_string("--"));

semantic_atom operator_plus_equal = string requires(matches_string("+="));
semantic_atom operator_minus_equal = string requires(matches_string("-="));
semantic_atom operator_multiply_equal = string requires(matches_string("*="));
semantic_atom operator_divide_equal = string requires(matches_string("/="));
semantic_atom operator_modulo_equal = string requires(matches_string("%="));
semantic_atom operator_xor_equal = string requires(matches_string("^="));

semantic_atom operator_not_equal = string requires(matches_string("!="));
semantic_atom operator_equal_equal = string requires(matches_string("=="));
semantic_atom operator_less_than_equal = string requires(matches_string("<="));
semantic_atom operator_greater_than_equal = string requires(matches_string(">="));

semantic_atom operator_logical_and = string requires(matches_string("&&"));
semantic_atom operator_logical_or = string requires(matches_string("||"));

semantic_atom operator_dot = string requires(matches_string("."));

semantic_atom operator_opening_bracket = string requires(matches_string("("));
semantic_atom operator_closing_bracket = string requires(matches_string(")"));

semantic_atom operator_opening_square_bracket = string requires(matches_string("["));
semantic_atom operator_closing_square_bracket = string requires(matches_string("]"));

semantic_atom operator_question_mark = string requires(matches_string("?"));
semantic_atom operator_colon = string requires(matches_string(":"));

semantic_atom operator_comma = string requires(matches_string(","));
                   
using function_call_operator = { operator_plus, operator_minus, operator_multiply, operator_divide, 
								operator_modulo, 
								operator_xor, operator_and, operator_or, operator_complement, operator_not, 
								operator_equal, operator_less_than, operator_greater_than, 
								operator_plus_plus, operator_minus_minus, 
								operator_plus_equal, operator_minus_equal, operator_multiply_equal, operator_modulo_equal, 
								operator_xor_equal, 
								operator_not_equal, operator_equal_equal, operator_less_than_equal, operator_greater_than_equal, 
								operator_logical_and, operator_logical_or,  
								operator_dot, 
								operator_question_mark, operator_colon };
								
using operator = { function_call_operator, 
                   operator_comma };

semantic_atom identifier = string requires(matches_regex("[_A-Za-z][_A-Za-z0-9]*"));

semantic_atom double_quote = string requires(matches_string("\""));

semantic_atom string_constant_character = (static) [[length(1)]] string requires(matches_regex("[^\\\\\\\"]"));

semantic_atom string_constant_escaped_character = (static) [[length(2)]] string requires(matches_regex("\\\\[^\\n]"));

using string_constant_body_element = { string_constant_character, string_constant_escaped_character };

semantic_token string_constant_body
<
	{ string_constant_body_element }
>;

semantic_token string_constant
<
	double_quote,
	string_constant_body,
	double_quote
>;

semantic_atom statement_terminator = string requires(matches_string(";"));

semantic_atom struct_keyword = string requires(matches_string("struct"));
semantic_atom struct_name = string requires(matches_regex("[_A-Za-z][_A-Za-z0-9]*"));

semantic_token struct_declaration
<
	struct_keyword,
	struct_name,
	statement_terminator
>;


semantic_atom bool = string requires(matches_string("bool"));
semantic_atom int8 = string requires(matches_string("int8"));
semantic_atom uint8 = string requires(matches_string("uint8"));
semantic_atom int16 = string requires(matches_string("int16"));
semantic_atom uint16 = string requires(matches_string("uint16"));
semantic_atom int32 = string requires(matches_string("int32"));
semantic_atom uint32 = string requires(matches_string("uint32"));
semantic_atom int64 = string requires(matches_string("int64"));
semantic_atom uint64 = string requires(matches_string("uint64"));

semantic_atom float32 = string requires(matches_string("float32"));
semantic_atom float64 = string requires(matches_string("float64"));

semantic_atom literal_int8 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_uint8 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_int16 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_uint16 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_int32 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_uint32 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_int64 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_uint64 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_float32 = string requires(matches_regex("[0-9]*"));
semantic_atom literal_float64 = string requires(matches_regex("[0-9]*"));

using constant = { literal_int8, literal_uint8, literal_int16, literal_uint16, literal_int32, literal_uint32, literal_int64, literal_uint64, 
                    literal_float32, literal_float64, 
                    c_string_constant, wide_string_constant, long_string_constant };
   
                    
semantic_atom c_string_prefix = string requires(matches_string("C"));
semantic_atom wide_string_prefix = string requires(matches_string("WC"));
semantic_atom long_string_prefix = string requires(matches_string("LC"));
                 
semantic_token c_string_constant
<
    c_string_prefix,
    string_constant
>;

semantic_token wide_string_constant
<
    wide_string_prefix,
    string_constant
>;

semantic_token long_string_constant
<
    long_string_prefix,
    string_constant
>;

semantic_atom array_begin = string requires(matches_string("float32"));
semantic_atom array_end = string requires(matches_string("float64"));

semantic_token array
<
    array_begin,
    ( constant ),
    array_end
>;

semantic_atom public_keyword = string requires(matches_string("public"));
semantic_atom private_keyword = string requires(matches_string("private"));
semantic_atom internal_keyword = string requires(matches_string("internal"));
semantic_atom extern_keyword = string requires(matches_string("extern"));

using function_access_declaration = { public_keyword, private_keyword, internal_keyword, extern_keyword };

semantic_atom opening_bracket = string requires(matches_string("("));
semantic_atom closing_bracket = string requires(matches_string(")"));

semantic_atom comma = string requires(matches_string(","));

semantic_atom function_parameter_name = string requires(matches_regex("[_A-Za-z][_A-Za-z0-9]*"));

semantic_token function_parameter
<
    var_keyword,
    function_parameter_name,
    colon,
	type_name
>;

semantic_token function_parameter_list_elements
<
	{ function_parameter, comma },
	[ function_parameter ]
>;

semantic_token function_parameter_list
<
	opening_bracket,
	function_parameter_list_elements,
	closing_bracket
>;

semantic_atom type_name_identifier = string requires(matches_regex("[_A-Za-z][_A-Za-z0-9]*"));

semantic_atom pointer_declaration = string requires(matches_string("*"));

semantic_token type_name
<
	type_name_identifier,
    { pointer_declaration }
>;

semantic_atom def_keyword = string requires(matches_string("def"));
semantic_atom var_keyword = string requires(matches_string("var"));
semantic_atom colon = string requires(matches_string(":"));


semantic_atom variable_name = string requires(matches_regex("[_A-Za-z][_A-Za-z0-9]*"));

semantic_atom opening_square_bracket = string requires(matches_string("["));
semantic_atom closing_square_bracket = string requires(matches_string("]"));

semantic_atom count = string requires(matches_regex("[0-9]*"));

semantic_token array_count
<
	opening_square_bracket,
	count,
	closing_square_bracket
>;

semantic_token assignment_expression
<
	operator_equal,
	expression_body
>;

using variable_definition = { uninitialized_variable_definition, initialized_variable_definition };

semantic_token uninitialized_variable_definition
<
	var_keyword,
    variable_name,
    colon,
	type_name,
	[ array_count ],
	[ assignment_expression ],
	statement_terminator
>;

semantic_token initialized_variable_definition
<
	var_keyword,
	variable_name,
	[ array_count ],
	assignment_expression,
	statement_terminator
>;

semantic_atom octal_constant = string requires(matches_regex("0[0-7]*"));
semantic_atom decimal_constant = string requires(matches_regex("[1-9][0-9]*"));
semantic_atom hexadecimal_constant = string requires(matches_regex("0x[0-9A-Fa-f]*"));
semantic_atom float_constant = string requires(matches_regex("[0-9]*\\.[0-9]*[fF]"));
semantic_atom double_constant = string requires(matches_regex("[0-9]*\\.[0-9]*"));

semantic_token bracketed_expression
<
	opening_bracket,
	expression_body,
	closing_bracket
>;

semantic_token subscript_expression
<
	opening_square_bracket,
	expression_body,
	closing_square_bracket
>;

using function_call_parameter_expression_element = { function_call_operator, bracketed_expression, subscript_expression, function_call, identifier, constant };

semantic_token function_call_parameter_expression
<
	( function_call_parameter_expression_element )
>;

semantic_token function_call_parameters
<
	[ function_call_parameter_expression, { comma, function_call_parameter_expression } ]
>;

semantic_token function_call_parameter_list
<
	opening_bracket,
	function_call_parameters,
	closing_bracket
>;

semantic_token function_call
<
	identifier,
	function_call_parameter_list
>;

using expression_element = { function_call, operator, identifier, bracketed_expression, subscript_expression, constant };

semantic_token expression_body
<
	{ expression_element }
>;

semantic_token expression
<
	expression_body,
	statement_terminator
>;

semantic_token statement_block
<
	opening_brace,
	{ function_statement },
	closing_brace
>;

semantic_atom for_keyword = string requires(matches_string("for"));

semantic_token for_initialization_expression
<
	[ expression_body ]
>;

semantic_token for_condition_expression
<
	[ expression_body ]
>;

semantic_token for_post_expression
<
	[ expression_body ]
>;

semantic_token for_header
<
	for_keyword,
	opening_bracket,
	for_initialization_expression,
	statement_terminator,
	for_condition_expression,
	statement_terminator,
	for_post_expression,
	[statement_terminator],
	closing_bracket
>;

semantic_token for_loop
<
	for_header,
	statement_block
>;

semantic_atom return_keyword = string requires(matches_string("return"));

semantic_token return_statement
<
	return_keyword,
	[ expression_body ],
	statement_terminator
>;

semantic_atom if_keyword = string requires(matches_string("if"));

semantic_token if_condition
<
	expression_body
>;

using statement_block_or_statement = { statement_block, expression };

semantic_atom else_keyword = string requires(matches_string("else"));

semantic_token else_block
<
	else_keyword,
	statement_block_or_statement
>;

semantic_token if_statement
<
	if_keyword,
	opening_bracket,
	if_condition,
	closing_bracket,
	statement_block_or_statement, 
	[ else_block ]
>;

semantic_atom typedef_keyword = string requires(matches_string("typedef"));

semantic_atom type_alias = string requires(matches_regex("[_A-Za-z][_A-Za-z0-9]*"));

semantic_token typedef_definition
<
	typedef_keyword,
	type_name,
	type_alias,
	statement_terminator
>;

using function_statement = { return_statement, variable_definition, for_loop, if_statement, typedef_definition, expression };

semantic_token function_body
<
	{ function_statement }
>;


semantic_atom function_name_identifier = string requires(matches_regex("[_A-Za-z][_A-Za-z0-9]*"));

semantic_atom function_name_operator = string requires(matches_regex("(\\+|\\*|\\\\|/|\\!)"));

using function_name = { function_name_identifier, function_name_operator };

semantic_atom return_type_operator = string requires(matches_string("=>"));


semantic_token function_return_type_declaration
<
    return_type_operator,
    type_name
>;

semantic_token function_declaration
<
    [function_access_declaration], 
    def_keyword, 
    function_name, 
    function_parameter_list,
    [function_return_type_declaration],
    statement_terminator
>;

semantic_atom opening_brace = string requires(matches_string("{"));
semantic_atom closing_brace = string requires(matches_string("}"));

semantic_atom infix = string requires(matches_string("infix"));
semantic_atom prefix = string requires(matches_string("prefix"));

using operator_type = { infix, prefix };

semantic_token function_definition
<
    [function_access_declaration], 
    def_keyword,
    [ operator_type ], 
    function_name, 
    function_parameter_list,
    [function_return_type_declaration],
    opening_brace,
    function_body, 
    closing_brace
>;

semantic_atom import_keyword = string requires(matches_string("import"));

semantic_token import_statement
<
    import_keyword,
    string_constant,
    statement_terminator
>;

semantic_atom header_keyword = string requires(matches_string("header"));

semantic_token header_statement
<
    header_keyword,
    string_constant,
    statement_terminator
>;

semantic_token struct_member
<
	variable_definition
>;

using member_names_element = { struct_member, comma };

semantic_token struct_member_names
<
	{ member_names_element }
>;

semantic_token struct_members_definition
<
	type_name,
	struct_member_names,
	statement_terminator
>;

semantic_token struct_members
<
	{ variable_definition }
>;

semantic_token struct_definition
<
	struct_keyword,
	struct_name,
	opening_brace,
	struct_members,
	closing_brace
>;

root = {  function_declaration, function_definition, import_statement, header_statement, variable_definition, struct_definition };
